# 调试基础

---

### 1. 启用内核转储
获取用户空间的进程的内核转储

- 查询 core dump 的开关状态

    >　$ ulimit -c

    如果查的结果是 0，表示关闭了core dump。大多数Linux发行版默认情况下都是关闭的。

- 开启 core dump

    >　$ ulimit -c unlimited

    -c 后也可以跟内核转储文件的大小上限。发生问题时，进程的内存就可以全部存储到core文件中

- GDB 调试 dump 文件

    > $ gdb -c corefile exefile

### 2. 内核转储的一些高级功能

- 特定目录生成 core dump 文件
- 对生成的 core dump 文件进行压缩
- 利用内核转储掩码，过滤部分共享内存等

### 3. GDB 的基本使用方法(一)

1. 带着调试选项，构建调试对象

    > $ gcc -Wall -g 源文件 -o 输出文件名

    > CFLAGS = -Wall -g

    > $ ./configure CFLAGS = "-Wall -g"

2. 启动调试器

    > $ gdb 可执行程序名

3. 设置断点

    ```gdb
    break
        break Num
        break file:Num
        break function
        break file:function

    info breakpoints
    ```

4. 运行

    ```gdb
    run 参数
    ```

5. 显示栈帧

    ```gdb
    backtrace
    backtrace full
    ```

6. 显示变量值

    ```gdb
    print 变量
    print/FMT 变量
        x   十六进制
        d   十进制
        t   二进制
        c   字符
        i   指令，仅用于 x 命令
    ```

7. 显示寄存器

    ```gdb
    info registers
    print $寄存器名
    ```

8. 查看内存

    ```gdb
    x 地址
    x/nfu 地址
        n 正整数，代表需要显示的内存单元的个数，每个内存单元的大小由 u 定义
        f 显示的格式，同 print 的FMT
        u 表示每个单元的大小，默认4个字节，b：一个字节； h：两个字节； w：四个字节
        如 x/10i $eip，表示当前pc指针所指处开始的十条指令
    ```

9. 反汇编

    ```gdb
    disassemble
        反汇编当前所在函数

    disassemble function
        反汇编指定函数

    disassemble 地址
        反汇编某个地址

    disassemble 开始地址 结束地址
        反汇编某段区域

    /m 表示提示源代码行
    /r 表示显示十六进制代码
    ```

10. 单步执行

    next, step 单步执行的基本单位是源代码中的一行

    nexti, stepi 单步执行的基本单位是汇编代码中的一行

11. 监视点

    大型软件或大量使用指针的程序中，很难弄清楚变量在什么位置被改变。要想找到变量在何处被改变，可以使用 *watch* 命令

    ```gdb
    watch 变量
        变量发生变化时，停下来

    awatch 变量
        变量被访问、改变时，停下来

    rwatch 变量
        变量被访问时，停下来

    结合 contiue 使用即可
    ```

    断点和监视点的设置不同点在于，断点是基于源代码行设置的；监视点是基于变量的，那么设置监视点时必须处于被监视变量的上下文

12. 删除断点、监视点

    ```gdb
    info breakpoints

    delte Num
    ```

13. 改变变量的值

    调试的时候设置变量的值，可以更方便的观察程序的运行结果,而不必修改源代码

    ```gdb
    set variable VAR = EXP
    ```

14. 生成 core dump 文件

    ```gdb
    generate-core-file
    ```
